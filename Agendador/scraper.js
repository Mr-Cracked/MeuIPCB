const axios = require('axios');
const cheerio = require('cheerio');
const mongoose = require('mongoose');
const database = require('./database/basedados');
const { getGFSBucket } = require('./models/gridfs');
const Escola = require('./models/Escola');
const Curso = require('./models/Curso');
const puppeteer = require('puppeteer');
let contadorGuardados = 0;

const BASE_URL = 'https://www.ipcb.pt';

// Mapeamento dos nomes das escolas
const SCHOOL_NAME_MAP = {
    "agraria": "Escola Superior Agr√°ria",
    "artes-aplicadas": "Escola Superior de Artes Aplicadas",
    "educacao": "Escola Superior de Educa√ß√£o",
    "gestao": "Escola Superior de Gest√£o",
    "saude-dr-lopes-dias": "Escola Superior de Sa√∫de Dr. Lopes Dias",
    "tecnologia": "Escola Superior de Tecnologia de Castelo Branco"
};


//Obter as p√°ginas das escolas
async function getSchoolPages() {
    try {
        const { data } = await axios.get(`${BASE_URL}/estudar/academicos/horarios-e-calendarios/`);
        const $ = cheerio.load(data);
        const links = [];

        $('a').each((i, elem) => {
            const href = $(elem).attr('href');
            if (href && href.includes('/escolas/') && href.includes('/horarios-calendarios/')) {
                links.push(`${BASE_URL}${href}`);
            }
        });

        return links;
    } catch (error) {
        console.error('‚ùå Erro ao obter links das escolas:', error);
        return [];
    }
}

// Obter os links dos PDFs
async function getPdfLinks(schoolUrl) {
    try {
        const { data } = await axios.get(schoolUrl);
        const $ = cheerio.load(data);
        const links = [];

        $('a').each((i, elem) => {
            const href = $(elem).attr('href');
            if (href && href.endsWith('.pdf') && (href.includes("calendario") || href.includes("calend√°rio-escolar"))) {
                links.push({
                    nome: href.split('/').pop(),
                    url: href.startsWith('http') ? href : `${BASE_URL}${href}`,
                });
            }
        });

        console.log(`üì• Encontrados ${links.length} calend√°rios em ${schoolUrl}`);
        return links;
    } catch (error) {
        console.error(`‚ùå Erro ao obter PDFs da escola ${schoolUrl}:`, error);
        return [];
    }
}

//Apagar calend√°rios antigos
async function apagarCalendariosAntigos(nomeEscola) {
    try {
        const escola = await Escola.findOne({ nome: nomeEscola });

        if (escola && escola.calendarios.length > 0) {
            const gfsBucket = getGFSBucket();

            for (let calendario of escola.calendarios) {
                if (calendario.fileId) {
                    try {
                        await gfsBucket.delete(new mongoose.Types.ObjectId(calendario.fileId));
                        console.log(`üóëÔ∏è Ficheiro ${calendario.fileId} apagado do GridFS`);
                    } catch (err) {
                        if (err.message.includes('not found')) {
                            console.log(`‚ö†Ô∏è O ficheiro ${calendario.fileId} j√° n√£o existe no GridFS.`);
                        } else {
                            console.error(`‚ùå Erro ao apagar ficheiro ${calendario.fileId}:`, err);
                        }
                    }
                }
            }

            // üîÑ Remover os calend√°rios da escola para evitar duplica√ß√µes
            await Escola.updateOne({ nome: nomeEscola }, { $unset: { calendarios: 1 } });
            console.log(`üóëÔ∏è Todos os calend√°rios antigos apagados para: ${nomeEscola}`);
        }
    } catch (error) {
        console.error('‚ùå Erro ao apagar calend√°rios antigos:', error);
    }
}


async function fazerUploadParaGridFS(fileBuffer, fileName) {
    return new Promise((resolve, reject) => {
        const gfs = getGFSBucket();
        if (!fileBuffer || !Buffer.isBuffer(fileBuffer)) {
            return reject(new Error("Buffer inv√°lido ou vazio"));
        }

        const uploadStream = gfs.openUploadStream(fileName);

        uploadStream.on("finish", () => {
            if (!uploadStream.id) {
                return reject(new Error("ID n√£o recebido ap√≥s upload"));
            }
            resolve(uploadStream.id);
        });

        uploadStream.on("error", (err) => {
            reject(err);
        });

        uploadStream.end(fileBuffer); // ‚úÖ aqui estava o erro
    });
}




//Guardar ficheiro no MongoDB (GridFS)
async function guardarCalendario(nomeEscola, fileBuffer, fileName) {
    console.log(`üìù Guardando calend√°rio para ${nomeEscola}: ${fileName}`);

    try {
        await apagarCalendariosAntigos(nomeEscola)
        const gfsBucket = getGFSBucket();
        if (!gfsBucket) throw new Error("GridFSBucket n√£o inicializado");

        if (!fileBuffer || fileBuffer.length === 0) {
            throw new Error("Buffer inv√°lido ou vazio");
        }

        const fileId = await fazerUploadParaGridFS(fileBuffer, fileName);

        await Escola.findOneAndUpdate(
            { nome: nomeEscola },
            { $set: { calendarios: [{ fileId, nome: fileName }] } },
            { upsert: true }
        );

        console.log(`‚úÖ Ficheiro "${fileName}" guardado para ${nomeEscola}`);
    } catch (err) {
        console.error(`‚ùå Erro ao guardar o calend√°rio: ${err.message}`);
    }
}



//Download do ficheiro PDF
async function baixarCalendario(nomeEscola, file) {
    try {
        console.log(`üì• A baixar calend√°rio ${file.nome} de ${nomeEscola}...`);
        const response = await axios.get(file.url, { responseType: 'arraybuffer' });

        await guardarCalendario(nomeEscola, response.data, file.nome);
    } catch (error) {
        console.error(`‚ùå Erro ao baixar calend√°rio de ${nomeEscola}:`, error);
    }
}

//Fun√ß√£o principal do scraper
async function scrapeCalendariosEscolas() {
    await database();
    console.log('‚úÖ Conectado ao MongoDB!');

    console.log('üîÑ Iniciando Scraper de Calend√°rios...');
    const schoolPages = await getSchoolPages();

    const escolaUltimoFicheiro = {}; // Guardar apenas o √∫ltimo ficheiro por escola

    for (const schoolUrl of schoolPages) {
        const pdfLinks = await getPdfLinks(schoolUrl);
        const identificacaoEscola = schoolUrl.replace(BASE_URL, "").split("/").filter(part => part !== "")[1];
        const nomeEscola = SCHOOL_NAME_MAP[identificacaoEscola] || identificacaoEscola;

        if (pdfLinks.length > 0) {
            escolaUltimoFicheiro[nomeEscola] = pdfLinks[pdfLinks.length - 1]; // Apenas o √∫ltimo ficheiro
        }
    }

    console.log(`üì• ${Object.keys(escolaUltimoFicheiro).length} escolas com calend√°rios encontrados.`);

    // Processa apenas um ficheiro por escola
    for (const [nomeEscola, file] of Object.entries(escolaUltimoFicheiro)) {
        await baixarCalendario(nomeEscola, file);
    }

    console.log('‚úÖ Todos os ficheiros foram processados.');

}



// üõëüõëüõëüõëCURSOS


const PAGINA_CURSOS = `${BASE_URL}/escolas/tecnologia/horarios-calendarios/`;
const ESCOLA_NOME = "Escola Superior de Tecnologia de Castelo Branco";


async function getCursosComLinks() {
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    await page.goto(PAGINA_CURSOS, { waitUntil: 'domcontentloaded' });
    await new Promise(res => setTimeout(res, 2000));

    const html = await page.content();
    const $ = cheerio.load(html);
    const cursos = [];

    $('.tab-pane').each((_, el) => {
        const nomeCurso = $(el).find('h3').first().text().trim();
        const pdfLinks = [];

        $(el).find('a[href$=".pdf"]').each((i, link) => {
            const href = $(link).attr('href');
            if (href) {
                pdfLinks.push({
                    nome: href.split('/').pop(),
                    url: href.startsWith('http') ? href : `${BASE_URL}${href}`,
                    epoca: i === 0 ? 'Normal' : 'Exame'
                });
            }
        });

        if (nomeCurso && pdfLinks.length > 0) {
            cursos.push({
                nome: nomeCurso,
                pdfs: pdfLinks.slice(0, 2) // Apenas 2 por curso: normal e exame
            });
        }
    });

    await browser.close();
    return cursos;
}


async function apagarCalendariosAntigosCursos(nomeCurso) {
    try {
        const curso = await Curso.findOne({ nome: nomeCurso });
        if (curso && curso.calendarios.length > 0) {
            const gfsBucket = getGFSBucket();
            for (const cal of curso.calendarios) {
                if (cal.fileId) {
                    try {
                        await gfsBucket.delete(new mongoose.Types.ObjectId(cal.fileId));
                        console.log(`üóëÔ∏è Apagado antigo: ${cal.fileId}`);
                    } catch (err) {
                        console.error(`‚ö†Ô∏è Erro ao apagar antigo ${cal.fileId}: ${err.message}`);
                    }
                }
            }
            await Curso.updateOne({ nome: nomeCurso }, { $unset: { calendarios: 1 } });
        }
    } catch (err) {
        console.error(`‚ùå Erro ao apagar antigos de ${nomeCurso}:`, err.message);
    }
}


async function guardarCalendariosDoCurso(nomeCurso, pdfs) {
    const gfsBucket = getGFSBucket();
    const calendarios = [];

    await apagarCalendariosAntigosCursos(nomeCurso);

    for (const cal of pdfs) {
        try {
            const res = await axios.get(cal.url, { responseType: "arraybuffer" });
            const buffer = Buffer.from(res.data);
            const fileId = await fazerUploadParaGridFS(buffer, cal.nome);

            calendarios.push({
                epoca: cal.epoca,
                fileId,
                data_download: new Date()
            });

            console.log(`‚úÖ Guardado [${cal.epoca}] ${cal.nome} para ${nomeCurso}`);
        } catch (err) {
            console.error(`‚ùå Erro ao guardar ${cal.nome}: ${err.message}`);
        }
    }

    await Curso.findOneAndUpdate(
        { nome: nomeCurso },
        {
            Escola: ESCOLA_NOME,
            nome: nomeCurso,
            calendarios
        },
        { upsert: true }
    );
}

async function scrapeCalendariosCursos() {
    await database();
    console.log("‚úÖ Conectado ao MongoDB");

    const cursos = await getCursosComLinks();
    console.log(`üìö Encontrados ${cursos.length} cursos com calend√°rios.`);

    for (const curso of cursos) {
        await guardarCalendariosDoCurso(curso.nome, curso.pdfs);
    }

    console.log("‚úÖ Scraping dos calend√°rios dos cursos conclu√≠do");
    setTimeout(() => mongoose.connection.close(), 3000);
}


module.exports = {scrapeCalendariosEscolas, scrapeCalendariosCursos};
